{"ast":null,"code":"import React from 'react';\nimport { dequal } from 'dequal';\nfunction useDeepCompareMemoize(dependencies) {\n  const dependenciesRef = React.useRef(dependencies);\n  const signalRef = React.useRef(0);\n  if (!dequal(dependencies, dependenciesRef.current)) {\n    dependenciesRef.current = dependencies;\n    signalRef.current += 1;\n  }\n  return React.useMemo(() => dependenciesRef.current, [signalRef.current]);\n}\n\n/**\n * `useDeepCompareCallback` will return a memoized version of the callback that\n * only changes if one of the `dependencies` has changed.\n *\n * Warning: `useDeepCompareCallback` should not be used with dependencies that\n * are all primitive values. Use `React.useCallback` instead.\n *\n * @see {@link https://react.dev/reference/react/useCallback}\n */\n\nfunction useDeepCompareCallback(callback, dependencies) {\n  return React.useCallback(callback, useDeepCompareMemoize(dependencies));\n}\n\n/**\n * Accepts a function that contains imperative, possibly effectful code.\n *\n * Warning: `useDeepCompareEffect` should not be used with dependencies that\n * are all primitive values. Use `React.useEffect` instead.\n *\n * @see {@link https://react.dev/reference/react/useEffect}\n */\n\nfunction useDeepCompareEffect(effect, dependencies) {\n  React.useEffect(effect, useDeepCompareMemoize(dependencies));\n}\n\n/**\n * `useDeepCompareImperativeHandle` customizes the instance value that is exposed to parent components when using `ref`.\n * As always, imperative code using refs should be avoided in most cases.\n *\n * `useDeepCompareImperativeHandle` should be used with `React.forwardRef`.\n *\n * It's similar to `useImperativeHandle`, but uses deep comparison on the dependencies.\n *\n * Warning: `useDeepCompareImperativeHandle` should not be used with dependencies that\n * are all primitive values. Use `React.useImperativeHandle` instead.\n *\n * @see {@link https://react.dev/reference/react/useImperativeHandle}\n */\n\nfunction useDeepCompareImperativeHandle(ref, init, dependencies) {\n  React.useImperativeHandle(ref, init, useDeepCompareMemoize(dependencies));\n}\n\n/**\n * The signature is identical to `useDeepCompareEffect`, but it fires synchronously after all DOM mutations.\n * Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside\n * `useDeepCompareLayoutEffect` will be flushed synchronously, before the browser has a chance to paint.\n *\n * Prefer the standard `useDeepCompareEffect` when possible to avoid blocking visual updates.\n *\n * If you’re migrating code from a class component, `useDeepCompareLayoutEffect` fires in the same phase as\n * `componentDidMount` and `componentDidUpdate`.\n *\n * Warning: `useDeepCompareLayoutEffect` should not be used with dependencies that\n * are all primitive values. Use `React.useLayoutEffect` instead.\n *\n * @see {@link https://react.dev/reference/react/useLayoutEffect}\n */\n\nfunction useDeepCompareLayoutEffect(effect, dependencies) {\n  React.useLayoutEffect(effect, useDeepCompareMemoize(dependencies));\n}\n\n/**\n * `useDeepCompareMemo` will only recompute the memoized value when one of the\n * `dependencies` has changed.\n *\n * Warning: `useDeepCompareMemo` should not be used with dependencies that\n * are all primitive values. Use `React.useMemo` instead.\n *\n * @see {@link https://react.dev/reference/react/useMemo}\n */\n\nfunction useDeepCompareMemo(factory, dependencies) {\n  return React.useMemo(factory, useDeepCompareMemoize(dependencies));\n}\nexport { useDeepCompareCallback, useDeepCompareEffect, useDeepCompareImperativeHandle, useDeepCompareLayoutEffect, useDeepCompareMemo };","map":{"version":3,"names":["useDeepCompareMemoize","dependencies","dependenciesRef","React","useRef","signalRef","dequal","current","useMemo","useDeepCompareCallback","callback","useCallback","useDeepCompareEffect","effect","useEffect","useDeepCompareImperativeHandle","ref","init","useImperativeHandle","useDeepCompareLayoutEffect","useLayoutEffect","useDeepCompareMemo","factory"],"sources":["/Users/kaylei/work/chester/node_modules/.pnpm/use-deep-compare@1.3.0_react@18.3.1/node_modules/use-deep-compare/dist-src/useDeepCompareMemoize.js","/Users/kaylei/work/chester/node_modules/.pnpm/use-deep-compare@1.3.0_react@18.3.1/node_modules/use-deep-compare/dist-src/useDeepCompareCallback.js","/Users/kaylei/work/chester/node_modules/.pnpm/use-deep-compare@1.3.0_react@18.3.1/node_modules/use-deep-compare/dist-src/useDeepCompareEffect.js","/Users/kaylei/work/chester/node_modules/.pnpm/use-deep-compare@1.3.0_react@18.3.1/node_modules/use-deep-compare/dist-src/useDeepCompareImperativeHandle.js","/Users/kaylei/work/chester/node_modules/.pnpm/use-deep-compare@1.3.0_react@18.3.1/node_modules/use-deep-compare/dist-src/useDeepCompareLayoutEffect.js","/Users/kaylei/work/chester/node_modules/.pnpm/use-deep-compare@1.3.0_react@18.3.1/node_modules/use-deep-compare/dist-src/useDeepCompareMemo.js"],"sourcesContent":["import React from 'react';\nimport { dequal } from 'dequal';\nexport function useDeepCompareMemoize(dependencies) {\n  const dependenciesRef = React.useRef(dependencies);\n  const signalRef = React.useRef(0);\n\n  if (!dequal(dependencies, dependenciesRef.current)) {\n    dependenciesRef.current = dependencies;\n    signalRef.current += 1;\n  }\n\n  return React.useMemo(() => dependenciesRef.current, [signalRef.current]);\n}","import React from 'react';\nimport { useDeepCompareMemoize } from \"./useDeepCompareMemoize.js\";\n/**\n * `useDeepCompareCallback` will return a memoized version of the callback that\n * only changes if one of the `dependencies` has changed.\n *\n * Warning: `useDeepCompareCallback` should not be used with dependencies that\n * are all primitive values. Use `React.useCallback` instead.\n *\n * @see {@link https://react.dev/reference/react/useCallback}\n */\n\nexport function useDeepCompareCallback(callback, dependencies) {\n  return React.useCallback(callback, useDeepCompareMemoize(dependencies));\n}","import React from 'react';\nimport { useDeepCompareMemoize } from \"./useDeepCompareMemoize.js\";\n/**\n * Accepts a function that contains imperative, possibly effectful code.\n *\n * Warning: `useDeepCompareEffect` should not be used with dependencies that\n * are all primitive values. Use `React.useEffect` instead.\n *\n * @see {@link https://react.dev/reference/react/useEffect}\n */\n\nexport function useDeepCompareEffect(effect, dependencies) {\n  React.useEffect(effect, useDeepCompareMemoize(dependencies));\n}","import React from 'react';\nimport { useDeepCompareMemoize } from \"./useDeepCompareMemoize.js\";\n/**\n * `useDeepCompareImperativeHandle` customizes the instance value that is exposed to parent components when using `ref`.\n * As always, imperative code using refs should be avoided in most cases.\n *\n * `useDeepCompareImperativeHandle` should be used with `React.forwardRef`.\n *\n * It's similar to `useImperativeHandle`, but uses deep comparison on the dependencies.\n *\n * Warning: `useDeepCompareImperativeHandle` should not be used with dependencies that\n * are all primitive values. Use `React.useImperativeHandle` instead.\n *\n * @see {@link https://react.dev/reference/react/useImperativeHandle}\n */\n\nexport function useDeepCompareImperativeHandle(ref, init, dependencies) {\n  React.useImperativeHandle(ref, init, useDeepCompareMemoize(dependencies));\n}","import React from 'react';\nimport { useDeepCompareMemoize } from \"./useDeepCompareMemoize.js\";\n/**\n * The signature is identical to `useDeepCompareEffect`, but it fires synchronously after all DOM mutations.\n * Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside\n * `useDeepCompareLayoutEffect` will be flushed synchronously, before the browser has a chance to paint.\n *\n * Prefer the standard `useDeepCompareEffect` when possible to avoid blocking visual updates.\n *\n * If you’re migrating code from a class component, `useDeepCompareLayoutEffect` fires in the same phase as\n * `componentDidMount` and `componentDidUpdate`.\n *\n * Warning: `useDeepCompareLayoutEffect` should not be used with dependencies that\n * are all primitive values. Use `React.useLayoutEffect` instead.\n *\n * @see {@link https://react.dev/reference/react/useLayoutEffect}\n */\n\nexport function useDeepCompareLayoutEffect(effect, dependencies) {\n  React.useLayoutEffect(effect, useDeepCompareMemoize(dependencies));\n}","import React from 'react';\nimport { useDeepCompareMemoize } from \"./useDeepCompareMemoize.js\";\n/**\n * `useDeepCompareMemo` will only recompute the memoized value when one of the\n * `dependencies` has changed.\n *\n * Warning: `useDeepCompareMemo` should not be used with dependencies that\n * are all primitive values. Use `React.useMemo` instead.\n *\n * @see {@link https://react.dev/reference/react/useMemo}\n */\n\nexport function useDeepCompareMemo(factory, dependencies) {\n  return React.useMemo(factory, useDeepCompareMemoize(dependencies));\n}"],"mappings":";;AAEO,SAASA,qBAAqBA,CAACC,YAAY,EAAE;EAClD,MAAMC,eAAe,GAAGC,KAAK,CAACC,MAAM,CAACH,YAAY,CAAC;EAClD,MAAMI,SAAS,GAAGF,KAAK,CAACC,MAAM,CAAC,CAAC,CAAC;EAEjC,IAAI,CAACE,MAAM,CAACL,YAAY,EAAEC,eAAe,CAACK,OAAO,CAAC,EAAE;IAClDL,eAAe,CAACK,OAAO,GAAGN,YAAY;IACtCI,SAAS,CAACE,OAAO,IAAI,CAAC;;EAGxB,OAAOJ,KAAK,CAACK,OAAO,CAAC,MAAMN,eAAe,CAACK,OAAO,EAAE,CAACF,SAAS,CAACE,OAAO,CAAC,CAAC;;;ACT1E;;;;;;;;;;AAUA,SAAgBE,sBAAsBA,CAACC,QAAQ,EAAET,YAAY,EAAE;EAC7D,OAAOE,KAAK,CAACQ,WAAW,CAACD,QAAQ,EAAEV,qBAAqB,CAACC,YAAY,CAAC,CAAC;;;ACXzE;;;;;;;;;AASA,SAAgBW,oBAAoBA,CAACC,MAAM,EAAEZ,YAAY,EAAE;EACzDE,KAAK,CAACW,SAAS,CAACD,MAAM,EAAEb,qBAAqB,CAACC,YAAY,CAAC,CAAC;;;ACV9D;;;;;;;;;;;;;;AAcA,SAAgBc,8BAA8BA,CAACC,GAAG,EAAEC,IAAI,EAAEhB,YAAY,EAAE;EACtEE,KAAK,CAACe,mBAAmB,CAACF,GAAG,EAAEC,IAAI,EAAEjB,qBAAqB,CAACC,YAAY,CAAC,CAAC;;;ACf3E;;;;;;;;;;;;;;;;AAgBA,SAAgBkB,0BAA0BA,CAACN,MAAM,EAAEZ,YAAY,EAAE;EAC/DE,KAAK,CAACiB,eAAe,CAACP,MAAM,EAAEb,qBAAqB,CAACC,YAAY,CAAC,CAAC;;;ACjBpE;;;;;;;;;;AAUA,SAAgBoB,kBAAkBA,CAACC,OAAO,EAAErB,YAAY,EAAE;EACxD,OAAOE,KAAK,CAACK,OAAO,CAACc,OAAO,EAAEtB,qBAAqB,CAACC,YAAY,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}